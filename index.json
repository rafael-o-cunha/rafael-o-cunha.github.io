[{"content":"T√≥picos: Contexto do Problema Objetivo do Experimento Ferramentas, Tecnologias e Premissas Procedimento / Metodologia Resultados Observados Aprendizados e Implica√ß√µes Pr√≥ximos Passos / Melhorias 1. Contexto do Problema Onde tudo come√ßou Decidi criar um site utilizando um gerador de sites est√°ticos (Hugo + PaperMod) para agilizar o processo. O foco inicial estava em criar uma visualiza√ß√£o melhor para os projetos que est√£o no meu GitHub, pois a gest√£o de README de reposit√≥rios e sua leitura podem ser cansativas.\nEstruturando a ideia A partir da cria√ß√£o do site, vi que seria vi√°vel e de baixo custo de desenvolvimento criar se√ß√µes de P\u0026amp;D que comportariam reposit√≥rios menos expressivos e completos (aqueles que armazenam experimentos), Projetos (para projetos funcionais e que agrupam conhecimento pr√°tico em suas funcionalidades) e Insights (para conte√∫dos que representem resumos, indica√ß√µes de materiais t√©cnicos interessantes, curiosidades etc.).\nE agora? Onde hospedar? Por fim, veio a pergunta: onde posso hospedar de forma simples e gratuita? Surge ent√£o o GitHub Pages e, com ele, dois reposit√≥rios: um para o projeto e outro para a publica√ß√£o do site.\nSimples por√©m melhor: N√£o perder o foco. Ao longo do desenvolvimento e dos experimentos, percebi o qu√£o repetitivo e mon√≥tono √© o processo de deploy utilizando dois reposit√≥rios, pois em um √© gerado o conte√∫do em uma pasta public e esta deve ser publicada no outro reposit√≥rio, que ser√° o site.\nOportunidade de aprendizado durante o processo de cria√ß√£o Vejo ent√£o a oportunidade: criar uma rotina com o GitHub Actions para realizar o deploy do site.\nResumo Criei meu site pessoal usando Hugo + PaperMod. Mantenho o c√≥digo-fonte em um reposit√≥rio separado. Mas o deploy no GitHub Pages acontece em outro reposit√≥rio (rafael-o-cunha.github.io). Toda vez que gera o site com hugo, preciso: copiar o /public abrir outro repo commitar enviar Repetitivo, suscet√≠vel a erro, quebra fluxo e interrompe foco. Decidi buscar uma forma de automatizar ‚Äî iniciando um pequeno P\u0026amp;D. 2. Objetivo do Experimento Este seria meu primeiro contato de forma pr√°tica com o Github Actions pois no dia a dia de desenvolvimento focamos sempre no neg√≥cio, nas funcionaliades, enquanto o deploy automatizado foi preparado e est√° l√° apenas sendo utilizado.\nSigo ent√£o na miss√£o de entender como funciona este recurso no Github e desenvolver experimentos para aprender e praticar.\nO objetivo do primeiro experimento com o Actions:\nAutoma√ß√£o total do fluxo de build + deploy. Verificar se √© poss√≠vel: Build do Hugo automaticamente em cada push Fazer deploy para um reposit√≥rio externo Garantir que o GitHub Actions possa realizar commit e push no repo do Pages Objetivo intermedi√°rio: Realizar build e publica√ß√£o manual no reposit√≥rio principal e o Actions apenas copiar a pasta public/ para o reposit√≥rio do site. Objetivo final: zerar esfor√ßo manual e manter o site sempre atualizado com um push no repo principal do projeto, onde o build e publica√ß√£o ser√£o autom√°ticos. Job to be Done: Eliminar atrito/passos e tempo no processo criativo de conte√∫do. 3. Ferramentas, Tecnologias e Premissas Ferramentas e Tecnologias Hugo (hugo:latest) Tema PaperMod Docker (Hugo √© executado em container) Makefile (para simplificar comandos) GitHub Actions Personal Access Token (PAT) com permiss√µes adequadas Reposit√≥rio rafael-hub (desenvolvimento) Reposit√≥rio rafael-o-cunha.github.io (produ√ß√£o) Premissas do Experimento O Hugo ser√° executado dentro de um container Docker. Haver√° duas Base URLs (dev e prod), e isso deve ser considerado no processo de build. O Makefile ser√° usado como interface principal para build e automa√ß√£o local. O foco do experimento √© automatiza√ß√£o, portanto a solu√ß√£o deve manter o fluxo simples para permitir foco em conte√∫do. Cada experimento no projeto ser√° registrado previamente como uma issue. A automa√ß√£o deve usar Action oficial ou workflow customizado para fazer deploy em reposit√≥rio externo. 4. Procedimento / Metodologia Abordagem adotada A Abordagem seguiu um ciclo incremental de experimenta√ß√£o avan√ßando no processo por tr√™s etapas macro em formato de perguntas e com isso foi realizado a pesquisa e experimenta√ß√£o de:\nO que √© preciso ter no reposit√≥rio base? O que √© preciso ter no reposit√≥rio de destino? O que precisa ser feito no GitHub e/ou reposit√≥rios para que ambos reposit√≥rios que originalmente s√£o independentes tivessem este fluxo de movimenta√ß√£o de arquivos? Prepara√ß√£o do ambiente VS Code Git Github Docker Hugo (Gerador de sites est√°ticos) HTML, CSS, Javascript e Markdown Makefile Execu√ß√£o passo a passo O Fluxo inicial era realizado de forma manual e portanto consistia em:\nEtapa 1 - Deploy manual Criar o Post com toda estrutura do conte√∫do e formata√ß√£o desejada. Realizar Commit para salvar as altera√ß√µes. Realizar o Build do Hugo para gerar a pasta /Public para que o post criado seja convertido em conte√∫do public√°vel. Realizar push para o reposit√≥rio remoto(Github - reposit√≥rio de desenvolvimento) Etapa 2 - Deploy manual Abrir o reposit√≥rio de destino na ferramenta de desenvolvimento. Copiar os arquivos da pasta /Public para o reposit√≥rio de destino. Realizar Commit para salvar as altera√ß√µes. Realizar push para o reposit√≥rio remoto(Github - Pages) Observa-se que este fluxo de cria√ß√£o n√£o √© pr√°tico, ainda h√° um volume consider√°vel de atividades t√©cnicas envolvidas na cria√ß√£o de conte√∫do, portanto visando aprimorar a experi√™ncia da cria√ß√£o de conte√∫do foi realizado a mudan√ßa para que o GitHub Actions fosse responv√°vel por realizar o deploy para produ√ß√£o. A mudan√ßa proposta deve eliminar o processo de publica√ß√£o do site.\nEtapa 3 - Analisando o processo, suas etapas e melhoria esperada Com uma vis√£o clara e experimentada do processo de cria√ß√£o e publica√ß√£o do conte√∫do pode-se observar a divis√£o entre tr√™s etapas para mudar o processo levando-o do estado A ao estado B para que na sequ√™ncia seja vi√°vel alcan√ßar o estado C, desta forma alacan√ßando melhoria consider√°vel no processo reduzindo quantidade de passos manuais e tempo.\nA) Cria√ß√£o + build manuais e Publica√ß√£o manual. B) Cria√ß√£o + build manuais e Publica√ß√£o autom√°tica. C) Cria√ß√£o + build autom√°ticos e Publica√ß√£o autom√°tica. Etapa 3.1 - Configurando o Reposit√≥rio de origem para/com o GitHub Actions: O que √© preciso ter no reposit√≥rio base?\nWorkflow do GitHub Actions configurado Um Personal Access Token (PAT) ou GitHub Token Fine-grained Um secret configurado no reposit√≥rio base Identificar quais arquivos/pastas ser√£o copiados O que √© preciso ter no reposit√≥rio de destino?\nPermiss√£o de escrita para o PAT criado Um branch destino para receber os arquivos (Opcional) Um diret√≥rio espec√≠fico para receber os arquivos O que precisa ser feito no GitHub e/ou reposit√≥rios para que ambos reposit√≥rios que originalmente s√£o independentes tivessem este fluxo de movimenta√ß√£o de arquivos?\nCriar um Personal Access Token (PAT) (3.1.1) Registrar o token como secret no reposit√≥rio base (3.1.2) Criar workflow no reposit√≥rio base para copiar os arquivos (3.1.3) ‚≠ê Etapa 3.1.1 - Criar um Personal Access Token (PAT): ‚ÜòÔ∏è Por que criar um Personal Access Token (PAT)?\nPorque o GitHub Actions roda dentro do reposit√≥rio base, e por padr√£o ele s√≥ tem permiss√£o para escrever no pr√≥prio reposit√≥rio, atrav√©s do token autom√°tico GITHUB_TOKEN.\nO GITHUB_TOKEN n√£o pode fazer push em outros reposit√≥rios. Ele s√≥ funciona dentro do reposit√≥rio onde o workflow est√° rodando.\n‚ÜòÔ∏è O que o PAT resolve?\nO PAT funciona como uma credencial criada por voc√™, com permiss√£o expl√≠cita para escrever no reposit√≥rio de destino.\nEle permite que o GitHub Actions:\nclone o reposit√≥rio de destino modifique os arquivos fa√ßa commit realize push Como se fosse voc√™ pr√≥prio executando isso localmente. ‚ÜòÔ∏è Sem o PAT, qualquer tentativa de push resultaria em erro de autentica√ß√£o:\n\u0026ldquo;Authentication failed ‚Äì You do not have permission to access this repository.\u0026rdquo;\nCriando Token\nV√° at√© o GitHub, clique no perfil(canto direito superior), clique em Settings Na tela de configura√ß√µes v√° at√© Developer settings Na tela de Developer settings v√° at√© Personal access tokens e ent√£o acesse: Fine-Grained tokens Clique no bot√£o que foi exibido: Generate new token D√™ um nome e descri√ß√£o ao token e siga os passos abaixo: Selecione os reposit√≥rios que poder√£o usar o token (Reposit√≥rio de origem que rodar√° o GitHub Actions e destino que receber√° os arquivos copiados pelo Actions) Em Permiss√µes adicione permiss√£o de leitura e escrita para que o token permita o GitHub Actions realize altera√ß√µes em abos reposit√≥rios escolhidos (isso permitir√° posteriormente alterar arquivos, e portanto executar build que publica novos arquivos na pasta /public) finalize a cria√ß√£o do PAT e copie-o para se editor de texto pois ele ser√° usado mais tarde. Resumo:\nSettings ‚Üí Developer settings ‚Üí Personal access tokens ‚Üí Fine-grained tokens\n‚≠ê Etapa 3.1.2 - Registrar o token como secret no reposit√≥rio base: ‚ÜòÔ∏è Por que registrar o token como secret no reposit√≥rio base?\nPorque o GitHub Actions precisa usar o PAT para acessar o reposit√≥rio de destino, mas: N√£o √© seguro colocar o token direto no arquivo YAML\n‚ÜòÔ∏è O que o secret resolve?\nProtege o token criptografado Permite que o workflow utilize o token sem expor o valor Mant√©m a seguran√ßa mesmo em pipelines p√∫blicos Mesmo que o reposit√≥rio base seja p√∫blico, os secrets n√£o s√£o revelados em nenhuma condi√ß√£o. Registrando o Token\nNavegue at√© o reposit√≥rio base e clique em settings. No menu que ser√° exibido, v√° at√© Secrets and variables e clique em Actions. Na aba Secrets que aparecer√° dever√° clicar em New repository secret. D√™ um nome para a Secret e cole o PAT copiado na etapa anterior no campo secret e clique em Add secret. A secret ir√° aparecer na lista de secrets dispon√≠veis neste reposit√≥rio para que possa ser utilizada no workflow. Resumo:\nSettings ‚Üí Secrets ‚Üí Actions ‚Üí New secret\n‚≠ê Etapa 3.1.3 - Criar workflow no reposit√≥rio base para copiar os arquivos: ‚ÜòÔ∏è Qual prop√≥sito desta etapa?\nO prop√≥sito desta etapa √© criar um mecanismo autom√°tico que executar√° o todo o fluxo de copiar os arquivos necess√°rios do reposit√≥rio base para o reposit√≥rio de destino sempre que for feito push para o branch maindo reposit√≥rio base.\nEm outras palavras:\nO Workflow √© em si a automa√ß√£o que realiza todo o processo.\n‚ÜòÔ∏è Como √© o Workflow deste experimento: ‚ÜòÔ∏è Como Um Workflow √© materializado no GitHub Actions para ser executado?\nNo in√≠cio a vis√£o era de que seria necess√°rio programar um script com alguma linguagem de programa√ß√£o ou .sh para realizar todo o processo, onde os comandos seriam executados passo a passo, por√©m durante a explora√ß√£o deste recurso ficou claro que poderia ser mais simples e diferente o que torna o experimento mais atrativo pois utiliza-se uma maneira declarativa atrav√©s de um arquivo .yaml para realizar o processo necess√°rio neste experimento.\n‚ÜòÔ∏è Ent√£o o que √© um Workflow no GitHub Actions?\nUm workflow √© um arquivo de instru√ß√µes que o GitHub interpreta para automatizar tarefas. Ele n√£o √© um programa tradicional escrito em Java, Python ou Go. Ele √© escrito em YAML, um formato de configura√ß√£o. Em outras palavras:\nVoc√™ n√£o programa um rob√¥ ‚Äî voc√™ descreve o que quer que o GitHub Actions execute.\nO GitHub cuida de:\ncriar a m√°quina virtual instalar o ambiente executar os passos autenticar rodar seus comandos ‚ÜòÔ∏è Ent√£o como o workflow realmente executa coisas?\nO Arquivo .yaml ir√° conter passos a serem realizados e nesta etapa pode-se criar comandos bash ou incluir a execu√ß√£o de arquivos de script, por√©m no caso do experimento que foi realizado foi necess√°rio apenas executar a√ß√µes prontas.\nA√ß√µes prontas s√£o como pe√ßas de lego j√° criadas pela comunidade e podem ser executadas diminuindo a necessidade de recria√ß√£o de passos comuns entre muitos projetos.\nLogo foi identificado que basta definir o fluxo de trabalho, por exemplo:\nQuando rodar (on) Onde rodar (runs-on) O que fazer (steps) Com quem fazer (actions) ‚ÜòÔ∏è Criando Workflow do experimento de deploy autom√°tico:\nPara que o github actions realize o proceso de c√≥pia foi criado no reposit√≥rio base a sequ√™ncia de diret√≥rios com o arquivo do workflow:\n. ‚îî‚îÄ‚îÄ .github ‚îî‚îÄ‚îÄ workflows ‚îî‚îÄ‚îÄ deploy.yml O Arquivo ficou com a seguinte estrutura:\nname: Deploy de arquivos est√°ticos para o GitHub Pages on: push: branches: - main jobs: deploy: # Especifica o tipo de runner (m√°quina virtual) onde os steps v√£o rodar runs-on: ubuntu-latest steps: - name: Checkout source repo # Utiliza a action oficial checkout para clonar o reposit√≥rio onde o workflow est√° sendo executado uses: actions/checkout@v4 with: # Realiza c√≥pia raza, ou seja, apenas do √∫ltimo commit. fetch-depth: 1 - name: Deploy public/ folder to GitHub Pages repo # Utiliza uma action pronta que facilita publicar conte√∫do em um repo de p√°ginas. uses: peaceiris/actions-gh-pages@v4 with: # Apenas copia a pasta public - espera-se que build j√° tenha sido realizado. publish_dir: ./public # Reposit√≥rio de destino (Pages) external_repository: usuario_github/usuario_github.github.io # Branch da publica√ß√£o publish_branch: main # Token de deploy personal_token: ${{ secrets.SECRET_TOKEN_LOREN_IPSUM }} # Limpar repo antes de copiar keep_files: false Entendendo os passos realizados nas instru√ß√µes do .yaml:\n√â disparado a cada push na branch main. Clona o reposit√≥rio atual. Usa a pasta public/ como conte√∫do para publicar. Conecta-se ao reposit√≥rio usuario_github.github.io usando um token secreto. Apaga todo o conte√∫do anterior do reposit√≥rio Pages. Publica o novo conte√∫do na branch main daquele reposit√≥rio. Resultado:\nSeu site do GitHub Pages √© atualizado automaticamente sempre que voc√™ der push no reposit√≥rio base(branch main).\nValida√ß√£o e testes ‚ÜòÔ∏è Nesta etapa o objetivo foi confirmar se o workflow realmente:\nExecuta no momento correto. Copia a pasta public/para o reposit√≥rio de pages. Criar commit automaticamente no reposit√≥rio de destino. Atualiza corretamente o conte√∫do publicado no GitHub Pages. Mant√©m previsibilidade eliminando a necessidade de deploy manual. üìù O primeiro passo foi garantir que o workflow disparasse corretamente para isso foi realizado o procedimento:\nRealizei um commit simples no reposit√≥rio base contendo apenas uma altera√ß√£o textual. Realizei pushpara o reposit√≥rio base (Remoto) na brach main Observei no menu \u0026ldquo;Actions\u0026rdquo; o Workflow sendo iniciado. üìä Crit√©rios de valida√ß√£o:\nO workflow apareceu na lista O status evoluiu para \u0026ldquo;in progress\u0026rdquo; e \u0026ldquo;sucess\u0026rdquo; Nenhum passo foi pulado. Este teste validou que o gatilho estava configurado corretamente.\nüìù Com o workflow disparado corretamente, a pr√≥xima verifica√ß√£o foi confirmar se cada etapa interna estava funcionando como esperado\nOs logs do GItHub Actions foram utilizados como fonte de dados para valida√ß√£o. Foi observado que o Checkout ocorreu com sucesso A op√ß√£o de c√≥pia raza fucionou corretamente. Verifiquei se a pasta public/ existia no workspace ‚ö†Ô∏è Isso confirma que o build manual realizado no experimento ocorreu corretamente. Deploy com Action reconheceu o reposit√≥rio externo. Autentica√ß√£o com o token funcionou corretamente. O reposit√≥rio de destino foi clonado corretamente. Todos os arquivos antigos foram removidos. Os arquivos da pasta public/ forma copiados. Foi realizado um commit autom√°tico. üìä Crit√©rios de valida√ß√£o:\nTodos os steps apareceram com marca√ß√£o verde Este teste validou que o fluxo estava funcionando corretamente\nüìù Testes de valida√ß√£o no reposit√≥rio de destino\nAp√≥s o workflow executar, o pr√≥ximo passo foi validar o reposit√≥rio que recebe o deploy.\nUm commit novo foi criado automaticamente. O conte√∫do da branch main do Pages foi substitu√≠do pelo conte√∫do da pasta public/. A √°rvore de diret√≥rios estava consistente com o que havia sido gerado localmente. üìä Crit√©rios de valida√ß√£o:\nA √°rvore de diret√≥rios estava consistente com o que havia sido gerado localmente. Este teste validou que o personal token, permiss√µes e secrets estavam configurados corretamente.\nüìù Teste de valida√ß√£o no site publicado\nCom tudo atualizado no reposit√≥rio de Pages, a √∫ltima valida√ß√£o foi diretamente no site.\nA URL do github pages foi acessada. Foi realizada limpeza de cache (CTRL + F5). üìä Crit√©rios de valida√ß√£o:\nNovo post publicado. Links funcionando. Assets (CSS/JS) carregando corretamente. Imagens e √≠cones renderizando. Aus√™ncia de erros no console do navegador. O site refletiu exatamente o conte√∫do da pasta public/, confirmando que o deploy foi conclu√≠do com sucesso.\nProblemas encontrados e ajustes feitos ‚ö†Ô∏è Foi identificado um problema quando estava elevando o processo do estado A para o estado B (quando o build √© manual e o deploy √© autom√°tico)\nDurante o processo de push para a branch main o GitHub Actions foi executado, por√©m ao realizar o deploy o site ficava em branco, e ao inspecionar o site foi observado que n√£o haviam arquivos publicados. O github actions est√° preparado para copiar a pasta public corretamente, o problema √© que ele n√£o identificava uma pasta public com conte√∫do e portanto apenas limpava o reposit√≥rio de destino. Analisando profundamente foi identificado que o problema n√£o estava no deploy autom√°tico mas no .gitignore que estava configurado para n√£o manter a pasta public/no reposit√≥rio remoto e portanto a mesma permanecia vazia. O Problema foi solucionado permitidindo o versionamento da pasta para que fosse enviada para o reposit√≥rio remoto. O problema mencionado anteriormente foi solucionado e fez o processo de experimenta√ß√£o ser executado elevando o processo do estado A para o estado B, e para o estado C ser√° necess√°rio realizar os passos abaixo:\nIgnorar a pasta public/ A URL correta de produ√ß√£o deve estar vis√≠vel para o embiente de build criado pelo GitHub Actions. O GitHub Actions dever√° realizar os comandos de build do Hugo para gerar a pasta public considerando a URL correta de produ√ß√£o. 5. Resultados Observados Estado Descri√ß√£o Passos de Build Passos de Publica√ß√£o Tempo de Build Tempo de Publica√ß√£o A Cria√ß√£o + build manuais e Publica√ß√£o manual 2 10 ~5‚Äì10 segundos ~4:45‚Äì5 minutos B Cria√ß√£o + build manuais e Publica√ß√£o autom√°tica 2 0 ~5‚Äì10 segundos ~35‚Äì40 segundos C Cria√ß√£o + build autom√°ticos e Publica√ß√£o autom√°tica 0 0 0 0 ‚ÜòÔ∏è Estado B alcan√ßado: ‚ÜòÔ∏è Observa√ß√µes:\nüìä Foi observado uma melhora consider√°vel na experi√™ncia de cria√ß√£o de conte√∫do e sua publica√ß√£o considerando que:\nO n√∫mero de passos caiu em 83%. O tempo de publica√ß√£o foi reduzido em ~86,7% e ~87,7% üìä A chance de erros humanos acontecerem no processo caiu dr√°sticamente pois:\nNo estado A haviam cerca de 12 passos que poderiam ocorrer erro humano. No estado B n√£o h√° mais passos a serem realizados para publica√ß√£o. 6. Aprendizados e Implica√ß√µes üí° Aprendizados:\nAutoma√ß√£o √© mais sobre remover atrito do que sobre tecnologia. Pequenas automa√ß√µes geram impactos desproporcionais. Redu√ß√£o de variabilidade e riscos. Entender como a ferramenta de automa√ß√£o trabalha √© mais importante do que o pipeline em si. Controle de seguran√ßa e permiss√µes √© essencial. A automa√ß√£o devolve a proposta de valor de \u0026ldquo;criar o conte√∫do\u0026rdquo; ao elimintar passos que n√£o contribuem diretamente para o objetivo final (Job to be done). üí° Implica√ß√µes\nA capacidade de produzir conte√∫do aumenta. A automa√ß√£o pode se tornar replic√°vel para outros projetos. Desenvolvimento de consci√™ncia sobre \u0026ldquo;fluxos de desenvolvimento\u0026rdquo;. A automa√ß√£o libera energia cognitiva. Base para criar expandir para CI/CD Completo. üß† O experimento n√£o s√≥ automatizou o processo mas trouxe consigo um fator exponencial que √© a replica√ß√£o atrav√©s do conhecimento obtido de forma que deste ponto em diante todo e qualquer projeto que eu desenvolva possa aplicar de maneira cada vez mais natural a automa√ß√£o e portanto aumentar a velocidade de cria√ß√£o de projetos, focando na proposta de valor.\nOs testes, valida√ß√µes e m√©tricas mostraram que antes o que parecia ter uma complexidade elevada para automatizar mostrou-se simples ao implementar um arquivo com as regras necess√°rias apenas, o que traz uma nova forma de ver o processo de desenvolvimento e entrega de valor por meio da tecnologia.\n7. Pr√≥ximos Passos / Melhorias Para os pr√≥ximos passos ser√£o implementados conjuntos de regras no arquivo do workflow para viabilizar o terceiro estado(C) do procesos de cria√ß√£o de conte√∫do.\nCriar conjunto de regras e configura√ß√µes para build pelo GitHub Actions. Evitar novamente que a pasta public/ seja versionada e trafegada em rede. Reduzir a quantidade de passos do processo de build para zero! Haver√° apenas o processo de cria√ß√£o de conte√∫do local que poder√° ser aprimorado posteriormente com uso de novas ferramentas ou melhoria das ferramentas locais atuais. #written_by_human\n","permalink":"http://localhost:1313/rnd-notes/github-actions-01/","summary":"\u003ch3 id=\"t√≥picos\"\u003eT√≥picos:\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#contexto-do-problema\"\u003eContexto do Problema\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#objetivo-do-experimento\"\u003eObjetivo do Experimento\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ferramentas-tecnologias-e-premissas\"\u003eFerramentas, Tecnologias e Premissas\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#procedimento-metodologia\"\u003eProcedimento / Metodologia\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#resultados-observados\"\u003eResultados Observados\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#aprendizados-e-implicacoes\"\u003eAprendizados e Implica√ß√µes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#proximos-passos-melhorias\"\u003ePr√≥ximos Passos / Melhorias\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"1-contexto-do-problema\"\u003e1. Contexto do Problema\u003c/h1\u003e\n\u003ch3 id=\"onde-tudo-come√ßou\"\u003eOnde tudo come√ßou\u003c/h3\u003e\n\u003cp\u003eDecidi criar um site utilizando um gerador de sites est√°ticos (Hugo + PaperMod) para agilizar o processo. O foco inicial estava em criar uma visualiza√ß√£o melhor para os projetos que est√£o no meu GitHub, pois a gest√£o de README de reposit√≥rios e sua leitura podem ser cansativas.\u003c/p\u003e","title":"üßë‚Äçüíª Experimento: Como criei um GitHub Action para publicar meu Site est√°tico em outro reposit√≥rio."},{"content":"Este reposit√≥rio cont√©m uma API REST simples para gerenciamento de tarefas (ToDo List), desenvolvida com Java 17 e Spring Boot.\nO projeto foi criado com foco em pr√°tica, explora√ß√£o de configura√ß√µes e refinamento de ambiente de desenvolvimento, incluindo execu√ß√£o com Docker, automa√ß√µes com Makefile, documenta√ß√£o com Swagger, al√©m da aplica√ß√£o de boas pr√°ticas de arquitetura.\nApesar de ser um projeto de estudo, foi estruturado para que sirva como base para pr√°ticas, experimenta√ß√µes e evolu√ß√£o cont√≠nua.\nüöÄ Tecnologias Utilizadas Java 17 Spring Boot 3 (Web, Data JPA) Spring Data JPA H2 Database Springdoc OpenAPI (Swagger UI) Lombok Maven Docker + Makefile JUnit (Spring Boot Test) Arquitetura em camadas:\ncontroller/ ‚Äì camadas de entrada service/ ‚Äì regras de neg√≥cio repository/ ‚Äì persist√™ncia model/ ‚Äì entidades doc/ ‚Äì configura√ß√£o Swagger üìÇ Estrutura do Projeto src/ ‚îú‚îÄ‚îÄ main/ ‚îÇ ‚îú‚îÄ‚îÄ java/com/big/tasks/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ controller/ # Endpoints REST ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ service/ # Regras de neg√≥cio ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ repository/ # CRUD JPA ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ model/ # Entidades ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ doc/ # Config OpenAPI/Swagger ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ TasksApplication.java ‚îÇ ‚îî‚îÄ‚îÄ resources/ ‚îÇ ‚îú‚îÄ‚îÄ application.properties ‚îÇ ‚îú‚îÄ‚îÄ static/ ‚îÇ ‚îî‚îÄ‚îÄ templates/ ‚îî‚îÄ‚îÄ test/ ‚îî‚îÄ‚îÄ java/com/big/tasks/ ‚îî‚îÄ‚îÄ TasksApplicationTests.java üê≥ Executando com Docker + Makefile Este projeto utiliza um Dockerfile preparado para desenvolvimento, mantendo o c√≥digo no host e depend√™ncias/cache dentro da imagem.\nO Makefile automatiza build, execu√ß√£o, reload, limpeza e entrada no container.\nüî® Build da imagem Docker make build ‚ñ∂Ô∏è Subir o container em modo interativo (debug) make run-it üöÄ Executar a aplica√ß√£o dentro do container make load üõë Parar somente a aplica√ß√£o (processos Java) make stop üßπ Parar e remover o container make down üî® Build da imagem Docker make build üß® Remover container + imagem make fclean üîÅ Pipeline completo (recomendado): make deep-run ‚ñ∂Ô∏è Rodando Sem Docker (opcional) Build: mvn clean install Executar: mvn spring-boot:run üìò Endpoints Dispon√≠veis M√©todo Endpoint Descri√ß√£o POST /tasks Criar uma nova Task GET /tasks Listar todas as Tasks GET /tasks/{id} Buscar Task por ID PUT /tasks/{id} Atualizar Task DELETE /tasks/{id} Remover Task URL base para as rotas: http://localhost:8080/api/v1 Acessar Swagger UI: http://localhost:8080/swagger-ui/index.html üß± Exemplo de Entidade Task { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Estudar Spring Boot\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Praticar cria√ß√£o de APIs REST\u0026#34;, \u0026#34;deadLine\u0026#34;: \u0026#34;2025-12-06T23:46:11.926Z\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2025-12-06T23:46:11.926Z\u0026#34;, \u0026#34;updatedAt\u0026#34;: \u0026#34;2025-12-06T23:46:11.926Z\u0026#34; } üéØ Conhecimentos Praticados Cria√ß√£o de APIs REST com Spring Boot Uso de Spring Data JPA Ambientes de desenvolvimento com H2 Documenta√ß√£o autom√°tica com Swagger/OpenAPI Arquitetura MVC / camadas (Controller ‚Üí Service ‚Üí Repository) Organiza√ß√£o e build com Maven Execu√ß√£o e desenvolvimento com Docker Automa√ß√£o via Makefile üîß Pr√≥ximos Passos / Melhorias\nHot Reload com Spring DevTools + Docker ‚Üí objetivo: alterar c√≥digo no host e executar automaticamente dentro do container üìÇ Reposit√≥rio do Projeto Tasks no Github\n","permalink":"http://localhost:1313/projects/api-pratica-springboot-tasks/","summary":"\u003cp\u003eEste reposit√≥rio cont√©m uma API REST simples para gerenciamento de tarefas (\u003cstrong\u003eToDo List\u003c/strong\u003e), desenvolvida com \u003cstrong\u003eJava 17\u003c/strong\u003e e \u003cstrong\u003eSpring Boot\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eO projeto foi criado com foco em \u003cstrong\u003epr√°tica\u003c/strong\u003e, \u003cstrong\u003eexplora√ß√£o de configura√ß√µes\u003c/strong\u003e e \u003cstrong\u003erefinamento de ambiente de desenvolvimento\u003c/strong\u003e, incluindo execu√ß√£o com \u003cstrong\u003eDocker\u003c/strong\u003e, automa√ß√µes com \u003cstrong\u003eMakefile\u003c/strong\u003e, documenta√ß√£o com \u003cstrong\u003eSwagger\u003c/strong\u003e, al√©m da aplica√ß√£o de boas pr√°ticas de arquitetura.\u003c/p\u003e\n\u003cp\u003eApesar de ser um projeto de estudo, foi estruturado para que sirva como base para pr√°ticas, experimenta√ß√µes e evolu√ß√£o cont√≠nua.\u003c/p\u003e","title":"üìù Tasks API ‚Äì Projeto de Estudos em Spring Boot"}]